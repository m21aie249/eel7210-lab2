/*

Code Function: Testbench Implementation of CPU for SystemC RISCV Project

EEL7210 Course: Hardware Software Co-Design: Lab2, SystemC_RISCV
Department of Electrical Engineering
Indian Institute of Technology, Jodhpur

Original code forked from repo: https://github.com/binodkumar23/IITJ_IDDEDA/tree/main/SystemC_RISCV
Original Code Authors: Vipul Sharma(B19CSE099) and Darsh Patel(B19CSE115)
Mentor: Dr. Binod Kumar

Modified code repo: https://github.com/m21aie249/eel7210-lab2
Modified by: Rohit Mathur (M21AIE249)
Mentor: Dr. Binod Kumar
Modifications: Add 5 new instructions, cleaned up code, added some comments

Added code marked with "M21AIE249"

References:
RISC-V Instructions: https://github.com/jameslzhu/riscv-card/blob/master/riscv-card.pdf
RISC-V Instruction Encoder/Interpreter, LupLab @ University of California, Davis:  https://luplab.gitlab.io/rvcodecjs/

For simulating this module, follow the instructions in Readme.md

*/

#include "systemc.h"
#include "cpu.cpp"

int sc_main(int argc, char* argv[]) {
    
    sc_signal<bool>   clock;
    sc_signal<bool> cpu_out;
    sc_signal<int> Program_Counter;
    sc_signal<sc_bv<32>> instruction;
    sc_signal<sc_bv<32*32>> instruction_memory;
    sc_signal<sc_bv<32*32>> data_memory;

    int i = 0;
    // Connect the DUT
    cpu cpu_1("cpu");
    cpu_1.clock(clock);
    cpu_1.cpu_out(cpu_out);
    cpu_1.Program_Counter(Program_Counter);
    cpu_1.instruction(instruction);
    cpu_1.instruction_memory(instruction_memory);
    cpu_1.data_memory(data_memory);

    sc_start(1, SC_NS);

    // Open VCD file
    sc_trace_file* wf = sc_create_vcd_trace_file("cpu");
    // Dump the desired signals
    sc_trace(wf, clock, "clock");
    sc_trace(wf, cpu_out, "cpu_out");
    sc_trace(wf, instruction, "instruction");
    sc_trace(wf, instruction_memory, "instruction_memory");
    sc_trace(wf, data_memory, "data_memory");

    // Initialize all variables
    instruction = "00000000000100000000000101001111";

    // R type insructions
    //0000001 0000100000 111 00010 0110011 (and)
    //0000001 0000100000 110 00010 0110011 (or)
    //0000001 0000100000 100 00010 0110011 (xor)
    //0000001 0000100000 000 00010 0110011 (add)
    //0000001 0000100000 001 00010 0110011 (sll) M21AIE249 -1
    //0000001 0000100000 101 00010 0110011 (srl) M21AIE249 -2

    // I type instructions

    // 000000000001 00011 010 00100 0000011 (lw)
    // 000000000001 00011 000 00100 0000011 (lb) M21AIE249 -3

    // S type instructions
    // 0000000 00000 00100 000 00000 0100011 (sb)

    // B type instructions
    // 0000000 00000 00001 001 00100 1100011 (bne)
    // 0000000 00000 00001 000 00100 1100011 (beq)
    // 0000000 00000 00001 100 00100 1100011 (blt) M21AIE249 -4
    // 0000000 00000 00001 101 00100 1100011 (bge) M21AIE249 -5

    // J type instructions
    // 00000000000000001 11111 1101111 (jal)

/*
	add x5, x0, x1 00000000000100000000001010110011
	sub x5, x0, x1 01000000000100000000001010110011
	and x5, x0, x1 00000000000100000111001010110011
	or x5, x0, x1 00000000000100000110001010110011
	xor x5, x0, x1 00000000000100000100001010110011
	add x5, x0, x1 00000000000100000000001010110011
	sub x5, x0, x1 01000000000100000000001010110011
	and x5, x0, x1 00000000000100000111001010110011
	sll x5, x0, x5 00000000010100000001001010110011
	srl x5, x0, x5 00000000010100000101001010110011
	beq x0, x2, 0 00000000001000000000000001100011
	bne x0, x1, 0 00000000000100000001000001100011
	bge x0, x2, 0 00000000001000000101000001100011
	lw x3, 0 00000000000000000010000110000011
	lb x3, 0 00000000000000000000000110000011
	blt x2 x0 0 00000000000000010100000001100011
*/



    instruction_memory =   "00000000000100000000001010110011010000000001000000000010101100110000000000010000011100101011001100000000000100000110001010110011"
"00000000000100000100001010110011000000000001000000000010101100110100000000010000000000101011001100000000000100000111001010110011"
"00000000010100000001001010110011000000000101000001010010101100110000000000100000000000000110001100000000000100000001000001100011"
"00000000001000000101000001100011000000000000000000100001100000110000000000000000000000011000001100000000000000010100000001100011"
"00000000000100000000001010110011010000000001000000000010101100110000000000010000011100101011001100000000000100000110001010110011"
"00000000000100000100001010110011000000000001000000000010101100110100000000010000000000101011001100000000000100000111001010110011"
"00000000010100000001001010110011000000000101000001010010101100110000000000100000000000000110001100000000000100000001000001100011"
"00000000001000000101000001100011000000000000000000100001100000110000000000000000000000011000001100000000000000010100000001100011";
    /*                                                                  
    data_memory        =    "00000010000100000111000101001111 00000010000100000110000101001111 00000010000100000100000101001111 00000010000100000111000101001111"
                            "00000010000100000111000101001111 00000010000100000111000101001111 00000010000100000110000101001111 00000010000100000100000101001111"
                            "00000010000100000111000101001111 00000010000100000111000101001111 00000010000100000110000101001111 00000010000100000100000101001111"
                            "00000010000100000111000101001111 00000010000100000111000101001111 00000010000100000110000101001111 00000010000100000100000101001111"
                            "00000010000100000111000101001111 00000010000100000111000101001111 00000010000100000110000101001111 00000010000100000100000101001111"
                            "00000010000100000111000101001111 00000010000100000111000101001111 00000010000100000110000101001111 00000010000100000100000101001111"
                            "00000010000100000111000101001111 00000010000100000111000101001111 00000010000100000110000101001111 00000010000100000100000101001111"
                            "00000010000100000111000101001111 00000010000100000111000101001111 00000010000100000110000101001111 00000010000100000100000101001111";
    */

    data_memory        =    "00000010000100000111000101001111000000100001000001110001010011110000001000010000011100010100111100000010000100000111000101001111"
    "00000010000100000111000101001111000000100001000001110001010011110000001000010000011100010100111100000010000100000111000101001111"
    "00000010000100000111000101001111000000100001000001110001010011110000001000010000011100010100111100000010000100000111000101001111"
    "00000010000100000111000101001111000000100001000001110001010011110000001000010000011100010100111100000010000100000111000101001111"
    "00000010000100000111000101001111000000100001000001110001010011110000001000010000011100010100111100000010000100000111000101001111"
    "00000010000100000111000101001111000000100001000001110001010011110000001000010000011100010100111100000010000100000111000101001111"
    "00000010000100000111000101001111000000100001000001110001010011110000001000010000011100010100111100000010000100000111000101001111"
    "00000010000100000111000101001111000000100001000001110001010011110000001000010000011100010100111100000010000100000111000101001111";

    Program_Counter = 0;
    // Here we run the clock
    for (i = 0;i < 32;i++) {
        clock = 0;
        sc_start(1, SC_NS);
        clock = 1;
        sc_start(1, SC_NS);
        //Program_Counter = Program_Counter+ 32;--> Carried out in the CPU module
    }
    
    cout << "@" << sc_time_stamp() << " Terminating simulation\n" << endl;
    sc_close_vcd_trace_file(wf);
    return 0;// Terminate simulation
}
